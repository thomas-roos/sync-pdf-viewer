<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Sync for GitHub Pages</title>
    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        select, input, button { padding: 8px; margin: 5px; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .warning { background: #fff3cd; color: #856404; }
        #qrcode { border: 1px solid #ddd; margin: 10px 0; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #qrSection { display: none; margin-top: 20px; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
        .url-display { background: #f8f9fa; padding: 10px; border-radius: 4px; word-break: break-all; font-family: monospace; margin: 10px 0; }
        #navigationControls { margin-top: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #f8f9fa; }
        #connectionStatus { padding: 10px; margin: 10px 0; border-radius: 4px; background: #f8f9fa; border: 1px solid #ddd; }
        .connected { color: #155724; font-weight: bold; }
        .disconnected { color: #721c24; font-weight: bold; }
        .connecting { color: #856404; font-weight: bold; }
        #connectionLog { height: 100px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-top: 10px; font-family: monospace; font-size: 12px; background: #f8f9fa; }
        .peer-info { background: #e3f2fd; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .debug-section { background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; font-size: 12px; }
        #folderStatus.success { background: #d4edda; color: #155724; }
        #folderStatus.error { background: #f8d7da; color: #721c24; }
        #folderStatus.info { background: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <div class="container">
        <h1>PDF Sync for GitHub Pages</h1>
        
        <!-- Connection Info -->
        <div class="peer-info">
            <div><strong>Connection ID:</strong> <span id="peerId">Connecting...</span></div>
            <div><strong>Role:</strong> <span id="roleDisplay">Detecting...</span></div>
            <div><strong>Connected Viewers:</strong> <span id="connectedPeers">0</span></div>
        </div>
        
        <div>
            <label for="chapterSelect">Section (1-14):</label>
            <select id="chapterSelect">
                <option value="">-- Select Section --</option>
                <option value="1">Section 1</option>
                <option value="2">Section 2</option>
                <option value="3">Section 3</option>
                <option value="4">Section 4</option>
                <option value="5">Section 5</option>
                <option value="6">Section 6</option>
                <option value="7">Section 7</option>
                <option value="8">Section 8</option>
                <option value="9">Section 9</option>
                <option value="10">Section 10</option>
                <option value="11">Section 11</option>
                <option value="12">Section 12</option>
                <option value="13">Section 13</option>
                <option value="14">Section 14</option>
            </select>
        </div>
        
        <div>
            <label for="verseSelect">Page (1-20):</label>
            <select id="verseSelect">
                <option value="">-- Select Page --</option>
                <option value="1">Page 1</option>
                <option value="2">Page 2</option>
                <option value="3">Page 3</option>
                <option value="4">Page 4</option>
                <option value="5">Page 5</option>
                <option value="6">Page 6</option>
                <option value="7">Page 7</option>
                <option value="8">Page 8</option>
                <option value="9">Page 9</option>
                <option value="10">Page 10</option>
                <option value="11">Page 11</option>
                <option value="12">Page 12</option>
                <option value="13">Page 13</option>
                <option value="14">Page 14</option>
                <option value="15">Page 15</option>
                <option value="16">Page 16</option>
                <option value="17">Page 17</option>
                <option value="18">Page 18</option>
                <option value="19">Page 19</option>
                <option value="20">Page 20</option>
            </select>
        </div>
        
        <div>
            <label for="selectedPdf">Selected PDF:</label>
            <input type="text" id="selectedPdf" readonly style="background: #f8f9fa; font-weight: bold;" placeholder="Section_Page">
        </div>
        
        <button id="generateBtn" onclick="generateQR()">Generate QR Code</button>
        
        <!-- Navigation Controls - ALWAYS VISIBLE for presenters -->
        <div id="navigationControls">
            <h4>Navigation Controls:</h4>
            <div style="margin-bottom: 10px;">
                <button id="prevBtn" onclick="previousPdf()">‚Üê Previous</button>
                <button id="nextBtn" onclick="nextPdf()">Next ‚Üí</button>
                <button id="startBtn" onclick="jumpToStart()">Jump to Start</button>
                <button id="endBtn" onclick="jumpToEnd()">Jump to End</button>
            </div>
            <div style="font-size: 14px; color: #666;">
                <strong>Keyboard Shortcuts:</strong> ‚Üê ‚Üí (navigate), Home (start), End (end), Ctrl+Enter (generate QR)
            </div>
            <div style="margin-top: 10px;">
                <strong>Current Position:</strong> <span id="currentPosition">Section -, Page -</span>
            </div>
        </div>
        
        <!-- Connection Status -->
        <div id="connectionStatus">
            <strong>Connection Status:</strong> <span id="connectionState" class="disconnected">Initializing</span>
            <div id="connectionLog"></div>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div id="qrSection">
            <h3>QR Code:</h3>
            <canvas id="qrcode"></canvas>
            <h3>URL:</h3>
            <div id="syncUrl" class="url-display"></div>
            <button id="copyBtn" onclick="copyUrl()">Copy URL</button>
        </div>
        
        <!-- Viewer Section (for PDF display) -->
        <div id="viewerSection" style="margin-top: 20px;">
            <div id="folderInputSection" style="margin-bottom: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #f8f9fa;">
                <h4>üìÅ PDF Folder Setup</h4>
                <div style="margin-bottom: 10px;">
                    <label for="localFolder"><strong>Local PDF Folder:</strong></label>
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 5px;">
                        <input type="text" id="localFolder" placeholder="Type folder path OR click Select Folder" style="flex: 1; padding: 8px;">
                        <button id="setFolderBtn" onclick="updateLocalFolder()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                            üìÇ Select Folder
                        </button>
                    </div>
                </div>
                <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                    <strong>Options:</strong>
                    ‚Ä¢ Click "Select Folder" to browse for a folder
                    ‚Ä¢ Or type a path manually and click the button
                    ‚Ä¢ Or use quick examples below
                </div>
                <div style="font-size: 12px; color: #666;">
                    <strong>Quick Examples:</strong>
                    <button onclick="setExampleFolder('example-pdfs')" style="font-size: 11px; padding: 2px 6px; margin: 2px;">example-pdfs</button>
                    <button onclick="setExampleFolder('pdfs')" style="font-size: 11px; padding: 2px 6px; margin: 2px;">pdfs</button>
                    <button onclick="setExampleFolder('documents')" style="font-size: 11px; padding: 2px 6px; margin: 2px;">documents</button>
                    <button onclick="setExampleFolder('./files')" style="font-size: 11px; padding: 2px 6px; margin: 2px;">./files</button>
                </div>
                <div id="folderStatus" style="margin-top: 10px; padding: 8px; border-radius: 4px; display: none;"></div>
            </div>
            
            <div id="pdfViewerContainer" style="width: 100%; height: 600px; border: 1px solid #ddd;">
                <div id="pdfPlaceholder" style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8f9fa; color: #666; flex-direction: column;">
                    <div style="font-size: 48px; margin-bottom: 20px;">üìÑ</div>
                    <div style="font-size: 18px; margin-bottom: 10px;">PDF Viewer</div>
                    <div style="font-size: 14px; text-align: center;">
                        Click "üìÇ Select Folder" above to choose your PDF folder<br>
                        <small style="color: #999;">Supports modern browsers with folder selection</small>
                    </div>
                </div>
                <iframe id="pdfViewer" style="width: 100%; height: 100%; border: none; display: none;"></iframe>
            </div>
        </div>
        
        <!-- Debug Section (collapsible) -->
        <div class="debug-section">
            <details>
                <summary><strong>üîß Debug Info</strong> (click to expand)</summary>
                <div style="margin-top: 10px;">
                    <button onclick="testConnection()">Test Connection</button>
                    <button onclick="clearLogs()">Clear Logs</button>
                    <div id="debugInfo" style="margin-top: 10px; font-family: monospace;"></div>
                </div>
            </details>
        </div>
    </div>
    
    <script>
        // Global variables
        let peer = null;
        let connections = new Map(); // Store multiple connections
        let isPresenter = true;
        let currentPdfName = '';
        let logs = [];
        
        // DOM elements
        const chapterSelect = document.getElementById('chapterSelect');
        const verseSelect = document.getElementById('verseSelect');
        const selectedPdf = document.getElementById('selectedPdf');
        const statusDiv = document.getElementById('status');
        const qrSection = document.getElementById('qrSection');
        const syncUrlDiv = document.getElementById('syncUrl');
        const localFolder = document.getElementById('localFolder');
        const pdfViewer = document.getElementById('pdfViewer');
        const connectionState = document.getElementById('connectionState');
        const connectionLog = document.getElementById('connectionLog');
        const peerId = document.getElementById('peerId');
        const roleDisplay = document.getElementById('roleDisplay');
        const connectedPeers = document.getElementById('connectedPeers');
        const navigationControls = document.getElementById('navigationControls');
        const currentPosition = document.getElementById('currentPosition');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const debugInfo = document.getElementById('debugInfo');
        
        // Logging function
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            logs.push(logEntry);
            console.log(logEntry);
            updateConnectionLog();
            updateDebugInfo();
        }
        
        function updateConnectionLog() {
            if (connectionLog) {
                connectionLog.innerHTML = logs.slice(-8).join('<br>');
                connectionLog.scrollTop = connectionLog.scrollHeight;
            }
        }
        
        function updateDebugInfo() {
            if (!debugInfo) return;
            
            let info = '';
            info += `Role: ${isPresenter ? 'Presenter' : 'Viewer'}<br>`;
            info += `Peer ID: ${peer ? peer.id || 'Connecting...' : 'Not initialized'}<br>`;
            info += `Connections: ${connections.size}<br>`;
            info += `Current PDF: ${currentPdfName || 'None'}<br>`;
            
            debugInfo.innerHTML = info;
        }
        
        function clearLogs() {
            logs = [];
            updateConnectionLog();
        }
        
        function updateConnectionStatus(state, message) {
            if (connectionState) {
                connectionState.textContent = state;
                connectionState.className = state.toLowerCase().replace(' ', '-');
            }
            if (message) {
                log(`üîó ${state}: ${message}`);
            }
        }
        
        function updateConnectedPeersCount() {
            if (connectedPeers) {
                connectedPeers.textContent = connections.size;
            }
        }
        
        // Event listeners
        chapterSelect.addEventListener('change', updateSelection);
        verseSelect.addEventListener('change', updateSelection);
        
        function updateSelection() {
            const section = chapterSelect.value;
            const page = verseSelect.value;
            
            log(`Selection changed: Section ${section}, Page ${page}`);
            
            if (section && page) {
                const pdfName = `${section}_${page}`;
                selectedPdf.value = pdfName;
                currentPdfName = `${pdfName}.pdf`;
                
                // ALWAYS show navigation controls for presenters (FIX for the issue)
                if (isPresenter) {
                    // Ensure navigation controls are visible
                    navigationControls.style.display = 'block';
                    updateNavigationButtons();
                    updateCurrentPosition();
                    
                    // Broadcast change to all connected viewers
                    broadcastPdfChange(parseInt(section), parseInt(page));
                } else {
                    // For viewers, try to load the PDF
                    loadCurrentPdf();
                }
                
                showStatus(`Selected: Section ${section}, Page ${page}`, 'success');
            } else {
                selectedPdf.value = '';
                currentPdfName = '';
                
                // Keep navigation controls visible for presenters even with incomplete selection
                if (isPresenter) {
                    navigationControls.style.display = 'block';
                    updateCurrentPosition();
                }
            }
            
            updateDebugInfo();
        }
        
        function updateNavigationButtons() {
            const section = parseInt(chapterSelect.value);
            const page = parseInt(verseSelect.value);
            
            if (prevBtn && nextBtn) {
                // Disable previous if at start (1_1) or no selection
                prevBtn.disabled = !section || !page || (section === 1 && page === 1);
                
                // Disable next if at end (14_20) or no selection
                nextBtn.disabled = !section || !page || (section === 14 && page === 20);
            }
        }
        
        function updateCurrentPosition() {
            const section = chapterSelect.value;
            const page = verseSelect.value;
            
            if (currentPosition) {
                if (section && page) {
                    currentPosition.textContent = `Section ${section}, Page ${page}`;
                } else {
                    currentPosition.textContent = 'Section -, Page -';
                }
            }
        }
        
        function previousPdf() {
            const section = parseInt(chapterSelect.value);
            const page = parseInt(verseSelect.value);
            
            if (!section || !page) return;
            
            let newSection = section;
            let newPage = page;
            
            if (page > 1) {
                newPage = page - 1;
            } else if (section > 1) {
                newSection = section - 1;
                newPage = 20;
            } else {
                return; // Already at start
            }
            
            chapterSelect.value = newSection.toString();
            verseSelect.value = newPage.toString();
            updateSelection();
            
            showStatus(`Navigated to Section ${newSection}, Page ${newPage}`, 'info');
        }
        
        function nextPdf() {
            const section = parseInt(chapterSelect.value);
            const page = parseInt(verseSelect.value);
            
            if (!section || !page) return;
            
            let newSection = section;
            let newPage = page;
            
            if (page < 20) {
                newPage = page + 1;
            } else if (section < 14) {
                newSection = section + 1;
                newPage = 1;
            } else {
                return; // Already at end
            }
            
            chapterSelect.value = newSection.toString();
            verseSelect.value = newPage.toString();
            updateSelection();
            
            showStatus(`Navigated to Section ${newSection}, Page ${newPage}`, 'info');
        }
        
        function jumpToStart() {
            chapterSelect.value = '1';
            verseSelect.value = '1';
            updateSelection();
            showStatus('Jumped to start: Section 1, Page 1', 'info');
        }
        
        function jumpToEnd() {
            chapterSelect.value = '14';
            verseSelect.value = '20';
            updateSelection();
            showStatus('Jumped to end: Section 14, Page 20', 'info');
        }
        
        // PeerJS initialization
        function initializePeerJS() {
            log('üöÄ Initializing PeerJS...');
            updateConnectionStatus('Connecting', 'Initializing PeerJS');
            
            // Check URL parameters to determine role
            const urlParams = new URLSearchParams(window.location.search);
            const presenterPeerId = urlParams.get('peer');
            
            if (presenterPeerId) {
                // This is a viewer connecting to a presenter
                isPresenter = false;
                roleDisplay.textContent = 'Viewer';
                log('üëÅÔ∏è Initializing as viewer');
                
                // Hide navigation controls for viewers
                navigationControls.style.display = 'none';
            } else {
                // This is a presenter
                isPresenter = true;
                roleDisplay.textContent = 'Presenter';
                log('üé§ Initializing as presenter');
                
                // ALWAYS show navigation controls for presenters
                navigationControls.style.display = 'block';
            }
            
            // Create peer with random ID
            peer = new Peer();
            
            // Peer events
            peer.on('open', function(id) {
                log(`‚úÖ PeerJS connected with ID: ${id}`);
                peerId.textContent = id;
                updateConnectionStatus('Ready', 'PeerJS initialized');
                
                if (!isPresenter && presenterPeerId) {
                    // Viewer: Connect to presenter
                    connectToPresenter(presenterPeerId);
                } else if (isPresenter) {
                    showStatus('Ready to generate QR codes for viewers', 'success');
                }
                
                updateDebugInfo();
            });
            
            peer.on('connection', function(conn) {
                log(`üìû Incoming connection from: ${conn.peer}`);
                handleIncomingConnection(conn);
            });
            
            peer.on('error', function(err) {
                log(`‚ùå PeerJS error: ${err.type} - ${err.message}`);
                updateConnectionStatus('Error', `PeerJS error: ${err.message}`);
                showStatus(`Connection error: ${err.message}`, 'error');
            });
            
            peer.on('disconnected', function() {
                log('üîå PeerJS disconnected');
                updateConnectionStatus('Disconnected', 'PeerJS disconnected');
            });
        }
        
        function handleIncomingConnection(conn) {
            log(`ü§ù Setting up connection with ${conn.peer}`);
            connections.set(conn.peer, conn);
            updateConnectedPeersCount();
            
            conn.on('open', function() {
                log(`‚úÖ Connection opened with ${conn.peer}`);
                updateConnectionStatus('Connected', `Connected to ${connections.size} viewer(s)`);
                showStatus(`Viewer connected: ${conn.peer.substring(0, 8)}...`, 'success');
                
                // Send current PDF state to new viewer
                const section = chapterSelect.value;
                const page = verseSelect.value;
                if (section && page) {
                    sendToPeer(conn, {
                        type: 'pdfChange',
                        section: parseInt(section),
                        page: parseInt(page),
                        timestamp: new Date().toISOString()
                    });
                }
            });
            
            conn.on('data', function(data) {
                log(`üì® Received data from ${conn.peer}: ${data.type}`);
                handleReceivedData(data, conn);
            });
            
            conn.on('close', function() {
                log(`üîå Connection closed with ${conn.peer}`);
                connections.delete(conn.peer);
                updateConnectedPeersCount();
                updateConnectionStatus(connections.size > 0 ? 'Connected' : 'Ready', 
                    `${connections.size} viewer(s) connected`);
            });
            
            conn.on('error', function(err) {
                log(`‚ùå Connection error with ${conn.peer}: ${err.message}`);
                connections.delete(conn.peer);
                updateConnectedPeersCount();
            });
        }
        
        function connectToPresenter(presenterPeerId) {
            log(`üìû Connecting to presenter: ${presenterPeerId}`);
            updateConnectionStatus('Connecting', 'Connecting to presenter');
            
            const conn = peer.connect(presenterPeerId);
            connections.set(presenterPeerId, conn);
            
            conn.on('open', function() {
                log('‚úÖ Connected to presenter!');
                updateConnectionStatus('Connected', 'Connected to presenter');
                showStatus('Connected to presenter! Real-time sync active.', 'success');
                updateConnectedPeersCount();
                
                // Send viewer info
                sendToPeer(conn, {
                    type: 'viewerConnected',
                    viewerId: peer.id,
                    timestamp: new Date().toISOString()
                });
            });
            
            conn.on('data', function(data) {
                log(`üì® Received data from presenter: ${data.type}`);
                handleReceivedData(data, conn);
            });
            
            conn.on('close', function() {
                log('üîå Disconnected from presenter');
                connections.delete(presenterPeerId);
                updateConnectedPeersCount();
                updateConnectionStatus('Disconnected', 'Disconnected from presenter');
                showStatus('Disconnected from presenter', 'error');
            });
            
            conn.on('error', function(err) {
                log(`‚ùå Connection error: ${err.message}`);
                updateConnectionStatus('Error', `Connection error: ${err.message}`);
                showStatus(`Connection failed: ${err.message}`, 'error');
            });
        }
        
        function handleReceivedData(data, conn) {
            switch (data.type) {
                case 'pdfChange':
                    log(`üìÑ PDF change received: Section ${data.section}, Page ${data.page}`);
                    
                    // Update UI
                    chapterSelect.value = data.section.toString();
                    verseSelect.value = data.page.toString();
                    selectedPdf.value = `${data.section}_${data.page}`;
                    currentPdfName = `${data.section}_${data.page}.pdf`;
                    
                    // Load PDF using the best available method
                    loadCurrentPdf();
                    
                    updateDebugInfo();
                    break;
                    
                case 'viewerConnected':
                    if (isPresenter) {
                        log(`üë§ Viewer connected: ${data.viewerId}`);
                        showStatus(`New viewer connected`, 'success');
                    }
                    break;
            }
        }
        
        function sendToPeer(conn, data) {
            try {
                conn.send(data);
                log(`üì§ Sent ${data.type} to ${conn.peer}`);
                return true;
            } catch (error) {
                log(`‚ùå Failed to send to ${conn.peer}: ${error.message}`);
                return false;
            }
        }
        
        function broadcastPdfChange(section, page) {
            log(`üì° Broadcasting PDF change: Section ${section}, Page ${page}`);
            
            const message = {
                type: 'pdfChange',
                section: section,
                page: page,
                timestamp: new Date().toISOString()
            };
            
            let successCount = 0;
            connections.forEach((conn, peerId) => {
                if (sendToPeer(conn, message)) {
                    successCount++;
                }
            });
            
            if (successCount > 0) {
                showStatus(`PDF synced to ${successCount} viewer(s)`, 'success');
            }
        }
        
        function generateQR() {
            const section = chapterSelect.value;
            const page = verseSelect.value;
            
            if (!section || !page) {
                showStatus('Please select both section and page before generating QR code', 'error');
                return;
            }
            
            if (!peer || !peer.id) {
                showStatus('PeerJS not ready yet, please wait...', 'error');
                return;
            }
            
            log(`üî≤ Generating QR code for Section ${section}, Page ${page}`);
            
            const pdfName = `${section}_${page}.pdf`;
            const baseUrl = window.location.origin + window.location.pathname;
            const syncUrl = `${baseUrl}?pdf=${encodeURIComponent(pdfName)}&peer=${encodeURIComponent(peer.id)}`;
            
            // Display URL
            syncUrlDiv.textContent = syncUrl;
            qrSection.style.display = 'block';
            
            // Generate QR code
            try {
                const canvas = document.getElementById('qrcode');
                const qr = new QRious({
                    element: canvas,
                    value: syncUrl,
                    size: 300,
                    level: 'L'
                });
                
                log('‚úÖ QR code generated successfully');
                showStatus(`QR code generated for Section ${section}, Page ${page}`, 'success');
                
            } catch (error) {
                log(`‚ùå QR generation failed: ${error.message}`);
                showStatus(`QR generation failed: ${error.message}`, 'error');
            }
        }
        
        function copyUrl() {
            const url = syncUrlDiv.textContent;
            navigator.clipboard.writeText(url).then(() => {
                showStatus('URL copied to clipboard!', 'success');
            }).catch(() => {
                showStatus('Failed to copy URL. Please copy manually.', 'error');
            });
        }
        
        async function updateLocalFolder() {
            // Check if we should open folder selector or use typed path
            const folderPath = localFolder.value.trim();
            
            if (!folderPath) {
                // No path entered, try to open folder selector
                await openFolderSelector();
                return;
            }
            
            log(`üìÅ Setting local folder: ${folderPath}`);
            
            // Try to load current PDF if available
            if (currentPdfName) {
                loadPdfFromFolder(folderPath, currentPdfName);
            } else {
                // Check if we can get PDF info from URL or selections
                const section = chapterSelect.value;
                const page = verseSelect.value;
                
                if (section && page) {
                    const pdfName = `${section}_${page}.pdf`;
                    currentPdfName = pdfName;
                    loadPdfFromFolder(folderPath, pdfName);
                } else {
                    log(`üìÅ Folder set: ${folderPath} (no PDF selected yet)`);
                    showStatus(`Folder set: ${folderPath} - waiting for PDF selection`, 'success');
                }
            }
        }
        
        async function openFolderSelector() {
            try {
                log('üìÇ Opening folder selector...');
                showStatus('Opening folder selector...', 'info');
                
                // Check if File System Access API is supported (Chrome, Edge)
                if ('showDirectoryPicker' in window) {
                    log('‚úÖ Using File System Access API');
                    const directoryHandle = await window.showDirectoryPicker();
                    
                    // Store the directory handle for later use
                    window.selectedDirectoryHandle = directoryHandle;
                    
                    // Update the input field
                    localFolder.value = directoryHandle.name;
                    log(`üìÅ Selected folder: ${directoryHandle.name}`);
                    showStatus(`Folder selected: ${directoryHandle.name}`, 'success');
                    
                    // Try to load current PDF using the directory handle
                    if (currentPdfName) {
                        await loadPdfFromDirectoryHandle(directoryHandle, currentPdfName);
                    } else {
                        const section = chapterSelect.value;
                        const page = verseSelect.value;
                        
                        if (section && page) {
                            const pdfName = `${section}_${page}.pdf`;
                            currentPdfName = pdfName;
                            await loadPdfFromDirectoryHandle(directoryHandle, pdfName);
                        }
                    }
                    
                } else {
                    // Fallback for browsers without File System Access API
                    log('‚ö†Ô∏è File System Access API not supported, using fallback');
                    await openFolderSelectorFallback();
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    log('üìÇ Folder selection cancelled by user');
                    showStatus('Folder selection cancelled', 'info');
                } else {
                    log(`‚ùå Error opening folder selector: ${error.message}`);
                    showStatus(`Error: ${error.message}`, 'error');
                }
            }
        }
        
        async function openFolderSelectorFallback() {
            // Create a file input for folder selection (webkitdirectory)
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            
            return new Promise((resolve, reject) => {
                input.onchange = async (event) => {
                    const files = Array.from(event.target.files);
                    if (files.length === 0) {
                        reject(new Error('No folder selected'));
                        return;
                    }
                    
                    // Get the folder path from the first file
                    const firstFile = files[0];
                    const pathParts = firstFile.webkitRelativePath.split('/');
                    const folderName = pathParts[0];
                    
                    log(`üìÅ Selected folder: ${folderName} (${files.length} files)`);
                    
                    // Store files for later access
                    window.selectedFolderFiles = files;
                    
                    // Update input field
                    localFolder.value = folderName;
                    showStatus(`Folder selected: ${folderName} (${files.length} files)`, 'success');
                    
                    // Try to load current PDF from selected files
                    if (currentPdfName) {
                        await loadPdfFromFileList(files, currentPdfName);
                    } else {
                        const section = chapterSelect.value;
                        const page = verseSelect.value;
                        
                        if (section && page) {
                            const pdfName = `${section}_${page}.pdf`;
                            currentPdfName = pdfName;
                            await loadPdfFromFileList(files, pdfName);
                        }
                    }
                    
                    resolve();
                };
                
                input.oncancel = () => {
                    reject(new Error('AbortError'));
                };
                
                // Trigger the file picker
                input.click();
            });
        }
        
        async function loadPdfFromDirectoryHandle(directoryHandle, pdfName) {
            try {
                log(`üìÑ Loading PDF from directory handle: ${pdfName}`);
                
                const fileHandle = await directoryHandle.getFileHandle(pdfName);
                const file = await fileHandle.getFile();
                
                // Create a blob URL for the PDF
                const pdfUrl = URL.createObjectURL(file);
                
                // Update PDF viewer
                const pdfViewer = document.getElementById('pdfViewer');
                const pdfPlaceholder = document.getElementById('pdfPlaceholder');
                const folderStatus = document.getElementById('folderStatus');
                
                if (pdfPlaceholder) pdfPlaceholder.style.display = 'none';
                if (pdfViewer) {
                    pdfViewer.style.display = 'block';
                    pdfViewer.src = pdfUrl;
                }
                
                log(`‚úÖ PDF loaded from directory: ${pdfName}`);
                showStatus(`PDF loaded: ${pdfName}`, 'success');
                
                if (folderStatus) {
                    folderStatus.style.display = 'block';
                    folderStatus.className = 'success';
                    folderStatus.textContent = `‚úÖ Successfully loaded: ${pdfName}`;
                    setTimeout(() => {
                        folderStatus.style.display = 'none';
                    }, 3000);
                }
                
            } catch (error) {
                log(`‚ùå Failed to load PDF from directory: ${error.message}`);
                showStatus(`Failed to load PDF: ${pdfName}`, 'error');
                
                const folderStatus = document.getElementById('folderStatus');
                if (folderStatus) {
                    folderStatus.style.display = 'block';
                    folderStatus.className = 'error';
                    folderStatus.textContent = `‚ùå File not found: ${pdfName}`;
                }
            }
        }
        
        async function loadPdfFromFileList(files, pdfName) {
            try {
                log(`üìÑ Loading PDF from file list: ${pdfName}`);
                
                // Find the PDF file in the selected files
                const pdfFile = files.find(file => 
                    file.name === pdfName || 
                    file.webkitRelativePath.endsWith(`/${pdfName}`)
                );
                
                if (!pdfFile) {
                    throw new Error(`PDF file not found: ${pdfName}`);
                }
                
                // Create a blob URL for the PDF
                const pdfUrl = URL.createObjectURL(pdfFile);
                
                // Update PDF viewer
                const pdfViewer = document.getElementById('pdfViewer');
                const pdfPlaceholder = document.getElementById('pdfPlaceholder');
                const folderStatus = document.getElementById('folderStatus');
                
                if (pdfPlaceholder) pdfPlaceholder.style.display = 'none';
                if (pdfViewer) {
                    pdfViewer.style.display = 'block';
                    pdfViewer.src = pdfUrl;
                }
                
                log(`‚úÖ PDF loaded from file list: ${pdfName}`);
                showStatus(`PDF loaded: ${pdfName}`, 'success');
                
                if (folderStatus) {
                    folderStatus.style.display = 'block';
                    folderStatus.className = 'success';
                    folderStatus.textContent = `‚úÖ Successfully loaded: ${pdfName}`;
                    setTimeout(() => {
                        folderStatus.style.display = 'none';
                    }, 3000);
                }
                
            } catch (error) {
                log(`‚ùå Failed to load PDF from file list: ${error.message}`);
                showStatus(`Failed to load PDF: ${pdfName}`, 'error');
                
                const folderStatus = document.getElementById('folderStatus');
                if (folderStatus) {
                    folderStatus.style.display = 'block';
                    folderStatus.className = 'error';
                    folderStatus.textContent = `‚ùå File not found: ${pdfName}`;
                }
            }
        }
        
        function loadPdfFromFolder(folderPath, pdfName) {
            const pdfPath = `${folderPath}/${pdfName}`;
            log(`üìÑ Loading PDF: ${pdfPath}`);
            
            // Show loading status
            const folderStatus = document.getElementById('folderStatus');
            const pdfPlaceholder = document.getElementById('pdfPlaceholder');
            const pdfViewer = document.getElementById('pdfViewer');
            
            if (folderStatus) {
                folderStatus.style.display = 'block';
                folderStatus.className = 'info';
                folderStatus.textContent = `Loading ${pdfName}...`;
            }
            
            // Hide placeholder and show iframe
            if (pdfPlaceholder) pdfPlaceholder.style.display = 'none';
            if (pdfViewer) pdfViewer.style.display = 'block';
            
            // Set the PDF source
            pdfViewer.src = pdfPath;
            
            // Add error handling for PDF loading
            pdfViewer.onload = function() {
                log(`‚úÖ PDF loaded successfully: ${pdfName}`);
                showStatus(`PDF loaded: ${pdfName} from ${folderPath}`, 'success');
                
                if (folderStatus) {
                    folderStatus.className = 'success';
                    folderStatus.textContent = `‚úÖ Successfully loaded: ${pdfName}`;
                    setTimeout(() => {
                        folderStatus.style.display = 'none';
                    }, 3000);
                }
            };
            
            pdfViewer.onerror = function() {
                log(`‚ùå Failed to load PDF: ${pdfPath}`);
                showStatus(`Failed to load PDF: ${pdfName} from ${folderPath}`, 'error');
                
                if (folderStatus) {
                    folderStatus.className = 'error';
                    folderStatus.textContent = `‚ùå Failed to load: ${pdfName}. Check if file exists in ${folderPath}/`;
                }
                
                // Show placeholder again on error
                if (pdfPlaceholder) pdfPlaceholder.style.display = 'flex';
                if (pdfViewer) pdfViewer.style.display = 'none';
            };
            
            // Force reload the iframe to ensure it loads the new PDF
            setTimeout(() => {
                try {
                    if (pdfViewer.contentWindow) {
                        pdfViewer.contentWindow.location.reload();
                    }
                } catch (error) {
                    // Ignore cross-origin errors - PDF should still load
                    log(`Note: Cross-origin reload blocked (this is normal)`);
                }
            }, 100);
            
            showStatus(`Loading PDF: ${pdfName} from ${folderPath}`, 'info');
        }
        
        async function loadCurrentPdf() {
            if (!currentPdfName) {
                log('üìÑ No PDF selected to load');
                return;
            }
            
            // Try different methods in order of preference
            if (window.selectedDirectoryHandle) {
                // Use File System Access API
                await loadPdfFromDirectoryHandle(window.selectedDirectoryHandle, currentPdfName);
            } else if (window.selectedFolderFiles) {
                // Use file list from webkitdirectory
                await loadPdfFromFileList(window.selectedFolderFiles, currentPdfName);
            } else {
                // Fallback to path-based loading
                const folderPath = localFolder.value.trim();
                if (folderPath) {
                    loadPdfFromFolder(folderPath, currentPdfName);
                } else {
                    log(`üìÑ PDF info received but no folder set yet`);
                    showStatus(`PDF synced - Click "Select Folder" to view PDFs`, 'warning');
                }
            }
        }
        
        function setExampleFolder(folderPath) {
            localFolder.value = folderPath;
            log(`üìÅ Set example folder: ${folderPath}`);
            updateLocalFolder();
        }
        
        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }
        
        function testConnection() {
            log('üß™ Testing PeerJS connection...');
            
            if (peer) {
                log(`Peer ID: ${peer.id}`);
                log(`Peer Open: ${!peer.destroyed}`);
                log(`Connected Peers: ${connections.size}`);
                log(`Role: ${isPresenter ? 'Presenter' : 'Viewer'}`);
                
                connections.forEach((conn, peerId) => {
                    log(`Connection ${peerId}: ${conn.open ? 'Open' : 'Closed'}`);
                });
            } else {
                log('‚ùå Peer not initialized');
            }
            
            updateDebugInfo();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (!isPresenter) return;
            
            switch (event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    previousPdf();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    nextPdf();
                    break;
                case 'Home':
                    event.preventDefault();
                    jumpToStart();
                    break;
                case 'End':
                    event.preventDefault();
                    jumpToEnd();
                    break;
                case 'Enter':
                    if (event.ctrlKey) {
                        event.preventDefault();
                        generateQR();
                    }
                    break;
            }
        });
        
        // Auto-load PDF when local folder is set
        localFolder.addEventListener('input', function() {
            if (this.value && currentPdfName) {
                updateLocalFolder();
            }
        });
        
        // Handle Enter key in the folder input
        localFolder.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                updateLocalFolder();
            }
        });
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ Page loaded, initializing...');
            
            // Check URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const pdfFromUrl = urlParams.get('pdf');
            const presenterPeerId = urlParams.get('peer');
            
            if (pdfFromUrl) {
                // This is a viewer
                currentPdfName = decodeURIComponent(pdfFromUrl);
                const pdfBase = currentPdfName.replace('.pdf', '');
                const [section, page] = pdfBase.split('_');
                
                if (section && page) {
                    chapterSelect.value = section;
                    verseSelect.value = page;
                    selectedPdf.value = pdfBase;
                }
                
                showStatus(`Viewer mode: Section ${section}, Page ${page}`, 'info');
                
                // Focus on the local folder input to prompt the user
                if (localFolder) {
                    localFolder.focus();
                    localFolder.scrollIntoView({ behavior: 'smooth' });
                }
            } else {
                showStatus('Presenter mode - select section and page, then generate QR', 'info');
            }
            
            // Initialize PeerJS
            initializePeerJS();
            
            // Update debug info
            updateDebugInfo();
        });
    </script>
</body>
</html>
